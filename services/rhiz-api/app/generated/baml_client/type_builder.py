# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
from baml_py import type_builder
from baml_py import baml_py
# These are exports, not used here, hence the linter is disabled
from baml_py.baml_py import FieldType, EnumValueBuilder, EnumBuilder, ClassBuilder # noqa: F401 # pylint: disable=unused-import
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME

class TypeBuilder(type_builder.TypeBuilder):
    def __init__(self):
        super().__init__(classes=set(
          ["ContextHighlight","ConvictionExplanation","ExtractedRelationship","FollowupMessage","ForwardingIntro","IntroFeasibility","IntroOrchestrationPlan","IntroductionMessage","MessageTone","OrchestrationStep","PathExplanation","RelationshipExtractionResult","RelationshipQualityAssessment","TrustExplanation","TrustScoreBreakdown",]
        ), enums=set(
          []
        ), runtime=DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME)

    # #########################################################################
    # Generated enums 0
    # #########################################################################


    # #########################################################################
    # Generated classes 15
    # #########################################################################

    @property
    def ContextHighlight(self) -> "ContextHighlightViewer":
        return ContextHighlightViewer(self)

    @property
    def ConvictionExplanation(self) -> "ConvictionExplanationViewer":
        return ConvictionExplanationViewer(self)

    @property
    def ExtractedRelationship(self) -> "ExtractedRelationshipViewer":
        return ExtractedRelationshipViewer(self)

    @property
    def FollowupMessage(self) -> "FollowupMessageViewer":
        return FollowupMessageViewer(self)

    @property
    def ForwardingIntro(self) -> "ForwardingIntroViewer":
        return ForwardingIntroViewer(self)

    @property
    def IntroFeasibility(self) -> "IntroFeasibilityViewer":
        return IntroFeasibilityViewer(self)

    @property
    def IntroOrchestrationPlan(self) -> "IntroOrchestrationPlanViewer":
        return IntroOrchestrationPlanViewer(self)

    @property
    def IntroductionMessage(self) -> "IntroductionMessageViewer":
        return IntroductionMessageViewer(self)

    @property
    def MessageTone(self) -> "MessageToneViewer":
        return MessageToneViewer(self)

    @property
    def OrchestrationStep(self) -> "OrchestrationStepViewer":
        return OrchestrationStepViewer(self)

    @property
    def PathExplanation(self) -> "PathExplanationViewer":
        return PathExplanationViewer(self)

    @property
    def RelationshipExtractionResult(self) -> "RelationshipExtractionResultViewer":
        return RelationshipExtractionResultViewer(self)

    @property
    def RelationshipQualityAssessment(self) -> "RelationshipQualityAssessmentViewer":
        return RelationshipQualityAssessmentViewer(self)

    @property
    def TrustExplanation(self) -> "TrustExplanationViewer":
        return TrustExplanationViewer(self)

    @property
    def TrustScoreBreakdown(self) -> "TrustScoreBreakdownViewer":
        return TrustScoreBreakdownViewer(self)



# #########################################################################
# Generated enums 0
# #########################################################################


# #########################################################################
# Generated classes 15
# #########################################################################

class ContextHighlightAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ContextHighlight")
        self._properties: typing.Set[str] = set([  "highlight",  "relevance_score",  "type",  ])
        self._props = ContextHighlightProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ContextHighlightProperties":
        return self._props


class ContextHighlightViewer(ContextHighlightAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ContextHighlightProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def highlight(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("highlight"))
    
    @property
    def relevance_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("relevance_score"))
    
    @property
    def type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("type"))
    
    


class ConvictionExplanationAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ConvictionExplanation")
        self._properties: typing.Set[str] = set([  "conviction_score",  "confidence_level",  "attestation_summary",  "key_attesters",  "positive_signals",  "negative_signals",  "recommendation",  "verification_status",  ])
        self._props = ConvictionExplanationProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ConvictionExplanationProperties":
        return self._props


class ConvictionExplanationViewer(ConvictionExplanationAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ConvictionExplanationProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def conviction_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("conviction_score"))
    
    @property
    def confidence_level(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence_level"))
    
    @property
    def attestation_summary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("attestation_summary"))
    
    @property
    def key_attesters(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("key_attesters"))
    
    @property
    def positive_signals(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("positive_signals"))
    
    @property
    def negative_signals(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("negative_signals"))
    
    @property
    def recommendation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recommendation"))
    
    @property
    def verification_status(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("verification_status"))
    
    


class ExtractedRelationshipAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ExtractedRelationship")
        self._properties: typing.Set[str] = set([  "participant_a_name",  "participant_a_handle",  "participant_b_name",  "participant_b_handle",  "relationship_type",  "relationship_strength",  "context",  "duration_years",  "evidence",  "confidence_score",  ])
        self._props = ExtractedRelationshipProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ExtractedRelationshipProperties":
        return self._props


class ExtractedRelationshipViewer(ExtractedRelationshipAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ExtractedRelationshipProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def participant_a_name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("participant_a_name"))
    
    @property
    def participant_a_handle(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("participant_a_handle"))
    
    @property
    def participant_b_name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("participant_b_name"))
    
    @property
    def participant_b_handle(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("participant_b_handle"))
    
    @property
    def relationship_type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("relationship_type"))
    
    @property
    def relationship_strength(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("relationship_strength"))
    
    @property
    def context(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("context"))
    
    @property
    def duration_years(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("duration_years"))
    
    @property
    def evidence(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("evidence"))
    
    @property
    def confidence_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("confidence_score"))
    
    


class FollowupMessageAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("FollowupMessage")
        self._properties: typing.Set[str] = set([  "message_body",  "subject_line",  "timing_justification",  "new_information",  "tone_adjustment",  ])
        self._props = FollowupMessageProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "FollowupMessageProperties":
        return self._props


class FollowupMessageViewer(FollowupMessageAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class FollowupMessageProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def message_body(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("message_body"))
    
    @property
    def subject_line(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("subject_line"))
    
    @property
    def timing_justification(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timing_justification"))
    
    @property
    def new_information(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("new_information"))
    
    @property
    def tone_adjustment(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("tone_adjustment"))
    
    


class ForwardingIntroAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ForwardingIntro")
        self._properties: typing.Set[str] = set([  "subject_line",  "intro_text",  "requester_summary",  "value_proposition",  "personalization_suggestions",  "response_template",  ])
        self._props = ForwardingIntroProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ForwardingIntroProperties":
        return self._props


class ForwardingIntroViewer(ForwardingIntroAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class ForwardingIntroProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def subject_line(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("subject_line"))
    
    @property
    def intro_text(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("intro_text"))
    
    @property
    def requester_summary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("requester_summary"))
    
    @property
    def value_proposition(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("value_proposition"))
    
    @property
    def personalization_suggestions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("personalization_suggestions"))
    
    @property
    def response_template(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("response_template"))
    
    


class IntroFeasibilityAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("IntroFeasibility")
        self._properties: typing.Set[str] = set([  "feasibility_score",  "feasibility_level",  "success_factors",  "blocking_factors",  "recommended_approach",  "timing_recommendation",  "alternative_suggestions",  ])
        self._props = IntroFeasibilityProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "IntroFeasibilityProperties":
        return self._props


class IntroFeasibilityViewer(IntroFeasibilityAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class IntroFeasibilityProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def feasibility_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("feasibility_score"))
    
    @property
    def feasibility_level(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("feasibility_level"))
    
    @property
    def success_factors(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success_factors"))
    
    @property
    def blocking_factors(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("blocking_factors"))
    
    @property
    def recommended_approach(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recommended_approach"))
    
    @property
    def timing_recommendation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timing_recommendation"))
    
    @property
    def alternative_suggestions(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("alternative_suggestions"))
    
    


class IntroOrchestrationPlanAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("IntroOrchestrationPlan")
        self._properties: typing.Set[str] = set([  "total_steps",  "steps",  "timeline_days",  "success_probability",  "risk_factors",  "mitigation_strategies",  "alternative_paths",  ])
        self._props = IntroOrchestrationPlanProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "IntroOrchestrationPlanProperties":
        return self._props


class IntroOrchestrationPlanViewer(IntroOrchestrationPlanAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class IntroOrchestrationPlanProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def total_steps(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total_steps"))
    
    @property
    def steps(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("steps"))
    
    @property
    def timeline_days(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("timeline_days"))
    
    @property
    def success_probability(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success_probability"))
    
    @property
    def risk_factors(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("risk_factors"))
    
    @property
    def mitigation_strategies(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("mitigation_strategies"))
    
    @property
    def alternative_paths(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("alternative_paths"))
    
    


class IntroductionMessageAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("IntroductionMessage")
        self._properties: typing.Set[str] = set([  "recipient_did",  "recipient_name",  "subject_line",  "message_body",  "message_tone",  "context_highlights",  "call_to_action",  "optimal_send_time",  "followup_timing_days",  "success_probability",  "personalization_score",  ])
        self._props = IntroductionMessageProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "IntroductionMessageProperties":
        return self._props


class IntroductionMessageViewer(IntroductionMessageAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class IntroductionMessageProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def recipient_did(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recipient_did"))
    
    @property
    def recipient_name(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recipient_name"))
    
    @property
    def subject_line(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("subject_line"))
    
    @property
    def message_body(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("message_body"))
    
    @property
    def message_tone(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("message_tone"))
    
    @property
    def context_highlights(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("context_highlights"))
    
    @property
    def call_to_action(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("call_to_action"))
    
    @property
    def optimal_send_time(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("optimal_send_time"))
    
    @property
    def followup_timing_days(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("followup_timing_days"))
    
    @property
    def success_probability(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success_probability"))
    
    @property
    def personalization_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("personalization_score"))
    
    


class MessageToneAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("MessageTone")
        self._properties: typing.Set[str] = set([  "formality",  "urgency",  "length",  ])
        self._props = MessageToneProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "MessageToneProperties":
        return self._props


class MessageToneViewer(MessageToneAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class MessageToneProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def formality(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("formality"))
    
    @property
    def urgency(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("urgency"))
    
    @property
    def length(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("length"))
    
    


class OrchestrationStepAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("OrchestrationStep")
        self._properties: typing.Set[str] = set([  "step_number",  "recipient_did",  "message_type",  "message",  "depends_on_step",  "success_criteria",  ])
        self._props = OrchestrationStepProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "OrchestrationStepProperties":
        return self._props


class OrchestrationStepViewer(OrchestrationStepAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class OrchestrationStepProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def step_number(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("step_number"))
    
    @property
    def recipient_did(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recipient_did"))
    
    @property
    def message_type(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("message_type"))
    
    @property
    def message(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("message"))
    
    @property
    def depends_on_step(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("depends_on_step"))
    
    @property
    def success_criteria(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success_criteria"))
    
    


class PathExplanationAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("PathExplanation")
        self._properties: typing.Set[str] = set([  "path_strength",  "hop_count",  "why_optimal",  "relationship_quality",  "alternative_paths_considered",  "why_others_rejected",  "risk_factors",  "success_probability",  "strategy_recommendation",  ])
        self._props = PathExplanationProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PathExplanationProperties":
        return self._props


class PathExplanationViewer(PathExplanationAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class PathExplanationProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def path_strength(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("path_strength"))
    
    @property
    def hop_count(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("hop_count"))
    
    @property
    def why_optimal(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("why_optimal"))
    
    @property
    def relationship_quality(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("relationship_quality"))
    
    @property
    def alternative_paths_considered(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("alternative_paths_considered"))
    
    @property
    def why_others_rejected(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("why_others_rejected"))
    
    @property
    def risk_factors(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("risk_factors"))
    
    @property
    def success_probability(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("success_probability"))
    
    @property
    def strategy_recommendation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("strategy_recommendation"))
    
    


class RelationshipExtractionResultAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("RelationshipExtractionResult")
        self._properties: typing.Set[str] = set([  "relationships",  "total_found",  "extraction_quality",  "ambiguous_cases",  ])
        self._props = RelationshipExtractionResultProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "RelationshipExtractionResultProperties":
        return self._props


class RelationshipExtractionResultViewer(RelationshipExtractionResultAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class RelationshipExtractionResultProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def relationships(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("relationships"))
    
    @property
    def total_found(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("total_found"))
    
    @property
    def extraction_quality(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("extraction_quality"))
    
    @property
    def ambiguous_cases(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("ambiguous_cases"))
    
    


class RelationshipQualityAssessmentAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("RelationshipQualityAssessment")
        self._properties: typing.Set[str] = set([  "has_sufficient_context",  "has_quantifiable_metrics",  "has_verification_potential",  "strength_justification",  "suggested_improvements",  "quality_score",  "attestation_potential",  ])
        self._props = RelationshipQualityAssessmentProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "RelationshipQualityAssessmentProperties":
        return self._props


class RelationshipQualityAssessmentViewer(RelationshipQualityAssessmentAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class RelationshipQualityAssessmentProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def has_sufficient_context(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("has_sufficient_context"))
    
    @property
    def has_quantifiable_metrics(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("has_quantifiable_metrics"))
    
    @property
    def has_verification_potential(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("has_verification_potential"))
    
    @property
    def strength_justification(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("strength_justification"))
    
    @property
    def suggested_improvements(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("suggested_improvements"))
    
    @property
    def quality_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("quality_score"))
    
    @property
    def attestation_potential(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("attestation_potential"))
    
    


class TrustExplanationAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("TrustExplanation")
        self._properties: typing.Set[str] = set([  "overall_trust_score",  "explanation_summary",  "breakdown",  "strengths",  "concerns",  "comparison_to_network",  "trend",  "recommendation",  ])
        self._props = TrustExplanationProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TrustExplanationProperties":
        return self._props


class TrustExplanationViewer(TrustExplanationAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class TrustExplanationProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def overall_trust_score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("overall_trust_score"))
    
    @property
    def explanation_summary(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("explanation_summary"))
    
    @property
    def breakdown(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("breakdown"))
    
    @property
    def strengths(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("strengths"))
    
    @property
    def concerns(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("concerns"))
    
    @property
    def comparison_to_network(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("comparison_to_network"))
    
    @property
    def trend(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("trend"))
    
    @property
    def recommendation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("recommendation"))
    
    


class TrustScoreBreakdownAst:
    def __init__(self, tb: type_builder.TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("TrustScoreBreakdown")
        self._properties: typing.Set[str] = set([  "component",  "score",  "weight",  "explanation",  "key_factors",  ])
        self._props = TrustScoreBreakdownProperties(self._bldr, self._properties)

    def type(self) -> baml_py.FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TrustScoreBreakdownProperties":
        return self._props


class TrustScoreBreakdownViewer(TrustScoreBreakdownAst):
    def __init__(self, tb: type_builder.TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, type_builder.ClassPropertyViewer]]:
        return [(name, type_builder.ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]
    


class TrustScoreBreakdownProperties:
    def __init__(self, bldr: baml_py.ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties # type: ignore (we know how to use this private attribute) # noqa: F821

    
    
    @property
    def component(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("component"))
    
    @property
    def score(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("score"))
    
    @property
    def weight(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("weight"))
    
    @property
    def explanation(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("explanation"))
    
    @property
    def key_factors(self) -> type_builder.ClassPropertyViewer:
        return type_builder.ClassPropertyViewer(self.__bldr.property("key_factors"))
    
    

