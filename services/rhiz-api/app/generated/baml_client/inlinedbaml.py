# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

_file_map = {

    "clients.baml": "// BAML Client Configuration for Rhiz Protocol\n// Manages LLM provider connections with fallback support\n\nclient<llm> GPT4 {\n  provider openai\n  options {\n    model gpt-4-turbo-preview\n    api_key env.OPENAI_API_KEY\n    temperature 0.7\n    max_tokens 2000\n  }\n}\n\nclient<llm> GPT4Mini {\n  provider openai\n  options {\n    model gpt-4o-mini\n    api_key env.OPENAI_API_KEY\n    temperature 0.7\n    max_tokens 1500\n  }\n}\n\nclient<llm> GPT35 {\n  provider openai\n  options {\n    model gpt-3.5-turbo\n    api_key env.OPENAI_API_KEY\n    temperature 0.7\n    max_tokens 1000\n  }\n}\n\n// Retry strategy for production reliability\nretry_policy StandardRetry {\n  max_retries 3\n  strategy {\n    type exponential_backoff\n    delay_ms 1000\n    multiplier 2\n  }\n}\n\n",
    "generators.baml": "// BAML Generator Configuration\n// Generates Python types and client code\n\ngenerator target {\n  output_type python/pydantic\n  output_dir \"../app/generated\"\n  version \"0.211.2\"\n}\n\n",
    "intro_orchestration.baml": "// Introduction Orchestration for Rhiz Protocol\n// Generic introduction orchestration across any relationship graph\n// Not specific to fundraising - works for any introduction use case\n\nclass MessageTone {\n  formality string  // \"formal\" | \"professional\" | \"casual\" | \"friendly\"\n  urgency string  // \"high\" | \"medium\" | \"low\"\n  length string  // \"brief\" | \"moderate\" | \"detailed\"\n}\n\nclass ContextHighlight {\n  highlight string\n  relevance_score int  // 0-100\n  type string  // \"shared_experience\" | \"mutual_connection\" | \"common_interest\" | \"complementary_skills\"\n}\n\nclass IntroductionMessage {\n  recipient_did string\n  recipient_name string\n  subject_line string\n  \n  message_body string\n  message_tone MessageTone\n  \n  context_highlights ContextHighlight[]\n  call_to_action string\n  \n  optimal_send_time string  // ISO 8601 timestamp\n  followup_timing_days int  // Days to wait before followup\n  \n  success_probability int  // 0-100, likelihood of positive response\n  personalization_score int  // 0-100, how tailored the message is\n}\n\nfunction GenerateIntroRequest(\n  requester_did: string,\n  requester_context: string,  // Who is requesting and why\n  intermediary_did: string,\n  intermediary_context: string,  // Who is the intermediary\n  target_did: string,\n  target_context: string,  // Who is the target\n  introduction_purpose: string,  // Why this introduction matters\n  relationship_data: string  // JSON of relationship strengths and context\n) -> IntroductionMessage {\n  client GPT4\n  prompt #\"\n    You are an expert at facilitating warm introductions through trust networks.\n    \n    Generate a personalized introduction request message.\n    \n    REQUESTER (Person asking for intro):\n    DID: {{ requester_did }}\n    Context: {{ requester_context }}\n    \n    INTERMEDIARY (Person making the intro):\n    DID: {{ intermediary_did }}\n    Context: {{ intermediary_context }}\n    \n    TARGET (Person to be introduced to):\n    DID: {{ target_did }}\n    Context: {{ target_context }}\n    \n    PURPOSE:\n    {{ introduction_purpose }}\n    \n    RELATIONSHIP DATA:\n    {{ relationship_data }}\n    \n    Craft a message that:\n    1. Respects the intermediary's time and relationship capital\n    2. Clearly states why this intro makes sense for all parties\n    3. Makes it easy for intermediary to say yes (low-friction)\n    4. Highlights mutual value (not extractive)\n    5. Provides specific context, not generic requests\n    6. Uses appropriate tone based on relationship formality\n    \n    Message should be:\n    - Professional and respectful\n    - Specific with relevant details\n    - Clear on the ask\n    - Highlighting mutual benefit where possible\n    \n    Include optimal timing for sending based on relationship context.\n    \n    Return structured JSON matching IntroductionMessage schema.\n  \"#\n}\n\nclass ForwardingIntro {\n  subject_line string\n  intro_text string  // Text intermediary forwards to target\n  \n  requester_summary string  // Brief summary of requester\n  value_proposition string  // Why target should care\n  \n  personalization_suggestions string[]  // Tips for intermediary to customize\n  response_template string?  // Optional template if target says yes\n}\n\nfunction GenerateForwardingIntro(\n  requester_context: string,\n  target_context: string,\n  intermediary_relationships: string,  // How intermediary knows both parties\n  introduction_purpose: string,\n  requested_outcome: string  // \"meeting\" | \"email_intro\" | \"advice\" | \"collaboration\"\n) -> ForwardingIntro {\n  client GPT4\n  prompt #\"\n    Generate the forwarding introduction text that the intermediary sends to the target.\n    \n    REQUESTER: {{ requester_context }}\n    TARGET: {{ target_context }}\n    INTERMEDIARY'S RELATIONSHIPS: {{ intermediary_relationships }}\n    PURPOSE: {{ introduction_purpose }}\n    DESIRED OUTCOME: {{ requested_outcome }}\n    \n    Create text that the intermediary can forward, including:\n    1. Why this intro makes sense (based on their relationships)\n    2. Brief but compelling requester summary\n    3. Clear value proposition for the target\n    4. Specific ask (meeting, intro, advice, collaboration)\n    5. Easy opt-out if not interested\n    \n    Make it easy for the intermediary - they should be able to use with minimal edits.\n    \n    Provide personalization suggestions so intermediary can add their own touch.\n    \n    Return structured JSON matching ForwardingIntro schema.\n  \"#\n}\n\nclass FollowupMessage {\n  message_body string\n  subject_line string\n  timing_justification string  // Why following up now\n  new_information string?  // Any updates to mention\n  tone_adjustment string  // How to adjust tone from original\n}\n\nfunction GenerateFollowup(\n  original_message: string,\n  days_since_sent: int,\n  any_responses: bool,\n  new_context: string?\n) -> FollowupMessage {\n  client GPT4Mini\n  prompt #\"\n    Generate an appropriate followup message.\n    \n    ORIGINAL MESSAGE: {{ original_message }}\n    DAYS SINCE SENT: {{ days_since_sent }}\n    ANY RESPONSES: {{ any_responses }}\n    {% if new_context %}\n    NEW CONTEXT: {{ new_context }}\n    {% endif %}\n    \n    Create a followup that:\n    1. Acknowledges time passed\n    2. Provides value or new information if possible\n    3. Maintains professionalism without being pushy\n    4. Makes it easy to respond\n    5. Offers graceful out if not interested\n    \n    Adjust tone based on time elapsed:\n    - 3-5 days: gentle reminder\n    - 7-10 days: more direct, assume they're busy\n    - 14+ days: assume low interest, soft close\n    \n    Return structured JSON matching FollowupMessage schema.\n  \"#\n}\n\n// Multi-step orchestration for complex intro paths (2+ hops)\nclass OrchestrationStep {\n  step_number int\n  recipient_did string\n  message_type string  // \"intro_request\" | \"forwarding_intro\" | \"followup\" | \"thank_you\"\n  message IntroductionMessage\n  depends_on_step int?  // Which step must succeed first\n  success_criteria string\n}\n\nclass IntroOrchestrationPlan {\n  total_steps int\n  steps OrchestrationStep[]\n  \n  timeline_days int  // Expected time to complete\n  success_probability int  // 0-100, overall probability\n  \n  risk_factors string[]\n  mitigation_strategies string[]\n  \n  alternative_paths string[]  // Backup intro paths if this fails\n}\n\nfunction PlanIntroductionOrchestration(\n  requester_did: string,\n  target_did: string,\n  intro_path: string,  // JSON array of DIDs in the path\n  relationship_data: string,  // Trust scores and context for each hop\n  introduction_purpose: string\n) -> IntroOrchestrationPlan {\n  client GPT4\n  prompt #\"\n    Plan a multi-step introduction orchestration through a trust network.\n    \n    REQUESTER: {{ requester_did }}\n    TARGET: {{ target_did }}\n    INTRODUCTION PATH: {{ intro_path }}\n    RELATIONSHIP DATA: {{ relationship_data }}\n    PURPOSE: {{ introduction_purpose }}\n    \n    Create a step-by-step orchestration plan:\n    \n    For each person in the path:\n    1. What message to send\n    2. When to send it (relative timing)\n    3. What success looks like\n    4. What to do if they don't respond\n    5. Dependencies (which steps must complete first)\n    \n    Consider:\n    - Relationship strength at each hop\n    - Optimal timing between steps\n    - Risk factors (weak relationships, timing, complexity)\n    - Backup paths if this fails\n    \n    Calculate realistic success probability based on:\n    - Path strength (higher = better)\n    - Number of hops (fewer = better)  \n    - Relationship recency\n    - Complexity of request\n    \n    Provide mitigation strategies for identified risks.\n    \n    Return structured JSON matching IntroOrchestrationPlan schema.\n  \"#\n}\n\n// Assess introduction feasibility before attempting\nclass IntroFeasibility {\n  feasibility_score int  // 0-100, how feasible this intro is\n  feasibility_level string  // \"very_high\" | \"high\" | \"moderate\" | \"low\" | \"very_low\"\n  \n  success_factors string[]\n  blocking_factors string[]\n  \n  recommended_approach string\n  timing_recommendation string  // \"now\" | \"wait_for_context\" | \"not_recommended\"\n  \n  alternative_suggestions string[]\n}\n\nfunction AssessIntroductionFeasibility(\n  requester_did: string,\n  target_did: string,\n  proposed_path: string,  // JSON of the path\n  relationship_data: string,\n  introduction_purpose: string,\n  timing_context: string?\n) -> IntroFeasibility {\n  client GPT4Mini\n  prompt #\"\n    Assess the feasibility of this introduction before attempting it.\n    \n    REQUESTER: {{ requester_did }}\n    TARGET: {{ target_did }}\n    PROPOSED PATH: {{ proposed_path }}\n    RELATIONSHIPS: {{ relationship_data }}\n    PURPOSE: {{ introduction_purpose }}\n    {% if timing_context %}\n    TIMING CONTEXT: {{ timing_context }}\n    {% endif %}\n    \n    Evaluate:\n    1. Strength of relationships in the path\n    2. Appropriateness of the request\n    3. Timing considerations\n    4. Potential obstacles\n    5. Success factors\n    \n    Provide:\n    - Overall feasibility score (0-100)\n    - Success factors (what's working in your favor)\n    - Blocking factors (what might prevent success)\n    - Recommended approach\n    - Timing recommendation (now vs. later vs. never)\n    - Alternative suggestions if feasibility is low\n    \n    Be honest and realistic in assessment.\n    \n    Return structured JSON matching IntroFeasibility schema.\n  \"#\n}\n\n",
    "relationship_extraction.baml": "// Relationship Extraction for Rhiz Protocol\n// Extract structured relationship data from unstructured text\n\nclass ExtractedRelationship {\n  participant_a_name string\n  participant_a_handle string?\n  participant_b_name string\n  participant_b_handle string?\n  \n  relationship_type string  // \"professional\" | \"personal\" | \"academic\" | \"transactional\" | \"organizational\"\n  relationship_strength int  // 0-100\n  \n  context string  // Brief description of how they know each other\n  duration_years float?\n  \n  evidence string[]  // Specific facts that support this relationship\n  confidence_score int  // 0-100, how confident in this extraction\n}\n\nclass RelationshipExtractionResult {\n  relationships ExtractedRelationship[]\n  total_found int\n  extraction_quality int  // 0-100\n  ambiguous_cases string[]  // Cases that need human review\n}\n\nfunction ExtractRelationshipsFromText(\n  text: string,\n  context_hint: string?\n) -> RelationshipExtractionResult {\n  client GPT4\n  prompt #\"\n    Extract all relationships mentioned in this text.\n    \n    TEXT:\n    {{ text }}\n    \n    {% if context_hint %}\n    CONTEXT: {{ context_hint }}\n    {% endif %}\n    \n    For each relationship found, extract:\n    1. Both participants (names and handles if mentioned)\n    2. Type of relationship (professional, personal, academic, etc.)\n    3. Relationship strength (0-100, based on described closeness)\n    4. Context (how they know each other)\n    5. Duration if mentioned\n    6. Specific evidence supporting the relationship\n    7. Your confidence in this extraction (0-100)\n    \n    Rules:\n    - Only extract explicit relationships (not inferred)\n    - Strength scoring:\n      * 90-100: Deep, long-term relationships (co-founders, close collaborators)\n      * 70-89: Strong professional relationships (colleagues, regular collaborators)\n      * 50-69: Established connections (worked together, know well)\n      * 30-49: Acquaintances (met multiple times, loose connection)\n      * 0-29: Minimal connection (met once, brief interaction)\n    \n    Flag ambiguous cases where human review is needed.\n    \n    Return structured JSON matching RelationshipExtractionResult schema.\n  \"#\n}\n\n// Assess quality of a relationship description\nclass RelationshipQualityAssessment {\n  has_sufficient_context bool\n  has_quantifiable_metrics bool\n  has_verification_potential bool\n  \n  strength_justification string\n  suggested_improvements string[]\n  \n  quality_score int  // 0-100, overall quality of relationship data\n  attestation_potential int  // 0-100, how likely others could attest\n}\n\nfunction AssessRelationshipQuality(\n  relationship_context: string,\n  claimed_strength: int\n) -> RelationshipQualityAssessment {\n  client GPT4Mini\n  prompt #\"\n    Assess the quality of this relationship description.\n    \n    CONTEXT: {{ relationship_context }}\n    CLAIMED STRENGTH: {{ claimed_strength }}\n    \n    Evaluate:\n    1. Does the context justify the claimed strength?\n    2. Is there sufficient detail for verification?\n    3. Are there quantifiable metrics (time, projects, outcomes)?\n    4. Could third parties reasonably attest to this?\n    \n    Provide:\n    - Quality assessment (bool checks)\n    - Justification for strength score\n    - Suggestions to improve relationship data quality\n    - Overall quality score (0-100)\n    - Attestation potential (how verifiable)\n    \n    Return structured JSON matching RelationshipQualityAssessment schema.\n  \"#\n}\n\n",
    "trust_explanations.baml": "// Trust Score Explanations for Rhiz Protocol\n// Generate human-readable explanations of trust calculations\n\nclass TrustScoreBreakdown {\n  component string  // \"reciprocity\" | \"consistency\" | \"reputation\" | \"conviction\"\n  score int  // 0-100\n  weight float  // How much this contributes to overall\n  explanation string\n  key_factors string[]\n}\n\nclass TrustExplanation {\n  overall_trust_score int\n  explanation_summary string\n  \n  breakdown TrustScoreBreakdown[]\n  \n  strengths string[]  // What makes this entity trustworthy\n  concerns string[]   // What could improve\n  \n  comparison_to_network string  // How they compare to average\n  trend string  // \"improving\" | \"stable\" | \"declining\"\n  \n  recommendation string  // Should others trust this entity?\n}\n\nfunction ExplainTrustScore(\n  entity_did: string,\n  trust_metrics: string,  // JSON of TrustMetrics\n  network_context: string  // JSON of network stats for comparison\n) -> TrustExplanation {\n  client GPT4\n  prompt #\"\n    Generate a human-readable explanation of this trust score.\n    \n    ENTITY: {{ entity_did }}\n    \n    TRUST METRICS:\n    {{ trust_metrics }}\n    \n    NETWORK CONTEXT:\n    {{ network_context }}\n    \n    Explain in clear language:\n    1. What the overall trust score means\n    2. How each component contributes\n    3. Key factors driving the score\n    4. Strengths (what's working well)\n    5. Concerns (what could improve)\n    6. How this compares to network average\n    7. Whether trust is improving, stable, or declining\n    8. Overall recommendation\n    \n    Make it accessible to non-technical users.\n    Avoid jargon - use plain language.\n    Be specific with examples where possible.\n    \n    Return structured JSON matching TrustExplanation schema.\n  \"#\n}\n\n// Explain conviction score for a relationship\nclass ConvictionExplanation {\n  conviction_score int\n  confidence_level string  // \"very_high\" | \"high\" | \"moderate\" | \"low\" | \"very_low\"\n  \n  attestation_summary string\n  key_attesters string[]  // Names/DIDs of notable attesters\n  \n  positive_signals string[]\n  negative_signals string[]\n  \n  recommendation string  // Should this relationship be trusted?\n  verification_status string  // \"strong\" | \"moderate\" | \"weak\" | \"unverified\"\n}\n\nfunction ExplainConvictionScore(\n  relationship_uri: string,\n  conviction_data: string,  // JSON of conviction calculation\n  attestations: string  // JSON array of attestations\n) -> ConvictionExplanation {\n  client GPT4\n  prompt #\"\n    Explain why this relationship has its conviction score.\n    \n    RELATIONSHIP: {{ relationship_uri }}\n    \n    CONVICTION DATA:\n    {{ conviction_data }}\n    \n    ATTESTATIONS:\n    {{ attestations }}\n    \n    Explain:\n    1. What the conviction score means (network confidence in this relationship)\n    2. Who attested to it (particularly high-reputation attesters)\n    3. Positive signals (verify attestations, high-reputation attesters, etc.)\n    4. Negative signals (disputes, low attestation count, etc.)\n    5. Overall confidence level\n    6. Recommendation on trusting this relationship\n    7. Verification status\n    \n    Use plain language. Be balanced in assessment.\n    \n    Return structured JSON matching ConvictionExplanation schema.\n  \"#\n}\n\n// Explain why a path was chosen for an introduction\nclass PathExplanation {\n  path_strength int\n  hop_count int\n  \n  why_optimal string  // Why this path was chosen\n  relationship_quality string[]  // Quality of each hop\n  \n  alternative_paths_considered int\n  why_others_rejected string\n  \n  risk_factors string[]\n  success_probability int  // 0-100\n  \n  strategy_recommendation string\n}\n\nfunction ExplainPathChoice(\n  from_did: string,\n  to_did: string,\n  chosen_path: string,  // JSON of path with hops\n  alternative_paths: string,  // JSON of other considered paths\n  selection_criteria: string\n) -> PathExplanation {\n  client GPT4Mini\n  prompt #\"\n    Explain why this introduction path was selected.\n    \n    FROM: {{ from_did }}\n    TO: {{ to_did }}\n    \n    CHOSEN PATH:\n    {{ chosen_path }}\n    \n    ALTERNATIVES:\n    {{ alternative_paths }}\n    \n    SELECTION CRITERIA:\n    {{ selection_criteria }}\n    \n    Explain:\n    1. Why this path is optimal (balance of strength, hops, feasibility)\n    2. Quality of each relationship in the path\n    3. How many alternatives were considered\n    4. Why alternatives were rejected\n    5. Risk factors in this path\n    6. Estimated success probability\n    7. Strategic recommendations for using this path\n    \n    Be specific about the tradeoffs involved.\n    \n    Return structured JSON matching PathExplanation schema.\n  \"#\n}\n\n",
}

def get_baml_files():
    return _file_map