# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
import typing_extensions
from enum import Enum


from pydantic import BaseModel, ConfigDict


import baml_py

CheckT = typing_extensions.TypeVar('CheckT')
CheckName = typing_extensions.TypeVar('CheckName', bound=str)

class Check(BaseModel):
    name: str
    expression: str
    status: str
class Checked(BaseModel, typing.Generic[CheckT, CheckName]):
    value: CheckT
    checks: typing.Dict[CheckName, Check]

def get_checks(checks: typing.Dict[CheckName, Check]) -> typing.List[Check]:
    return list(checks.values())

def all_succeeded(checks: typing.Dict[CheckName, Check]) -> bool:
    return all(check.status == "succeeded" for check in get_checks(checks))
# #########################################################################
# Generated enums (0)
# #########################################################################

# #########################################################################
# Generated classes (15)
# #########################################################################

class ContextHighlight(BaseModel):
    highlight: str
    relevance_score: int
    type: str

class ConvictionExplanation(BaseModel):
    conviction_score: int
    confidence_level: str
    attestation_summary: str
    key_attesters: typing.List[str]
    positive_signals: typing.List[str]
    negative_signals: typing.List[str]
    recommendation: str
    verification_status: str

class ExtractedRelationship(BaseModel):
    participant_a_name: str
    participant_a_handle: typing.Optional[str] = None
    participant_b_name: str
    participant_b_handle: typing.Optional[str] = None
    relationship_type: str
    relationship_strength: int
    context: str
    duration_years: typing.Optional[float] = None
    evidence: typing.List[str]
    confidence_score: int

class FollowupMessage(BaseModel):
    message_body: str
    subject_line: str
    timing_justification: str
    new_information: typing.Optional[str] = None
    tone_adjustment: str

class ForwardingIntro(BaseModel):
    subject_line: str
    intro_text: str
    requester_summary: str
    value_proposition: str
    personalization_suggestions: typing.List[str]
    response_template: typing.Optional[str] = None

class IntroFeasibility(BaseModel):
    feasibility_score: int
    feasibility_level: str
    success_factors: typing.List[str]
    blocking_factors: typing.List[str]
    recommended_approach: str
    timing_recommendation: str
    alternative_suggestions: typing.List[str]

class IntroOrchestrationPlan(BaseModel):
    total_steps: int
    steps: typing.List["OrchestrationStep"]
    timeline_days: int
    success_probability: int
    risk_factors: typing.List[str]
    mitigation_strategies: typing.List[str]
    alternative_paths: typing.List[str]

class IntroductionMessage(BaseModel):
    recipient_did: str
    recipient_name: str
    subject_line: str
    message_body: str
    message_tone: "MessageTone"
    context_highlights: typing.List["ContextHighlight"]
    call_to_action: str
    optimal_send_time: str
    followup_timing_days: int
    success_probability: int
    personalization_score: int

class MessageTone(BaseModel):
    formality: str
    urgency: str
    length: str

class OrchestrationStep(BaseModel):
    step_number: int
    recipient_did: str
    message_type: str
    message: "IntroductionMessage"
    depends_on_step: typing.Optional[int] = None
    success_criteria: str

class PathExplanation(BaseModel):
    path_strength: int
    hop_count: int
    why_optimal: str
    relationship_quality: typing.List[str]
    alternative_paths_considered: int
    why_others_rejected: str
    risk_factors: typing.List[str]
    success_probability: int
    strategy_recommendation: str

class RelationshipExtractionResult(BaseModel):
    relationships: typing.List["ExtractedRelationship"]
    total_found: int
    extraction_quality: int
    ambiguous_cases: typing.List[str]

class RelationshipQualityAssessment(BaseModel):
    has_sufficient_context: bool
    has_quantifiable_metrics: bool
    has_verification_potential: bool
    strength_justification: str
    suggested_improvements: typing.List[str]
    quality_score: int
    attestation_potential: int

class TrustExplanation(BaseModel):
    overall_trust_score: int
    explanation_summary: str
    breakdown: typing.List["TrustScoreBreakdown"]
    strengths: typing.List[str]
    concerns: typing.List[str]
    comparison_to_network: str
    trend: str
    recommendation: str

class TrustScoreBreakdown(BaseModel):
    component: str
    score: int
    weight: float
    explanation: str
    key_factors: typing.List[str]

# #########################################################################
# Generated type aliases (0)
# #########################################################################
