# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
import typing_extensions

import baml_py

from . import stream_types, types
from .runtime import DoNotUseDirectlyCallManager, BamlCallOptions

class LlmResponseParser:
    __options: DoNotUseDirectlyCallManager

    def __init__(self, options: DoNotUseDirectlyCallManager):
        self.__options = options

    def AssessIntroductionFeasibility(
        self, llm_response: str, baml_options: BamlCallOptions = {},
    ) -> types.IntroFeasibility:
        result = self.__options.merge_options(baml_options).parse_response(function_name="AssessIntroductionFeasibility", llm_response=llm_response, mode="request")
        return typing.cast(types.IntroFeasibility, result)

    def AssessRelationshipQuality(
        self, llm_response: str, baml_options: BamlCallOptions = {},
    ) -> types.RelationshipQualityAssessment:
        result = self.__options.merge_options(baml_options).parse_response(function_name="AssessRelationshipQuality", llm_response=llm_response, mode="request")
        return typing.cast(types.RelationshipQualityAssessment, result)

    def ExplainConvictionScore(
        self, llm_response: str, baml_options: BamlCallOptions = {},
    ) -> types.ConvictionExplanation:
        result = self.__options.merge_options(baml_options).parse_response(function_name="ExplainConvictionScore", llm_response=llm_response, mode="request")
        return typing.cast(types.ConvictionExplanation, result)

    def ExplainPathChoice(
        self, llm_response: str, baml_options: BamlCallOptions = {},
    ) -> types.PathExplanation:
        result = self.__options.merge_options(baml_options).parse_response(function_name="ExplainPathChoice", llm_response=llm_response, mode="request")
        return typing.cast(types.PathExplanation, result)

    def ExplainTrustScore(
        self, llm_response: str, baml_options: BamlCallOptions = {},
    ) -> types.TrustExplanation:
        result = self.__options.merge_options(baml_options).parse_response(function_name="ExplainTrustScore", llm_response=llm_response, mode="request")
        return typing.cast(types.TrustExplanation, result)

    def ExtractRelationshipsFromText(
        self, llm_response: str, baml_options: BamlCallOptions = {},
    ) -> types.RelationshipExtractionResult:
        result = self.__options.merge_options(baml_options).parse_response(function_name="ExtractRelationshipsFromText", llm_response=llm_response, mode="request")
        return typing.cast(types.RelationshipExtractionResult, result)

    def GenerateFollowup(
        self, llm_response: str, baml_options: BamlCallOptions = {},
    ) -> types.FollowupMessage:
        result = self.__options.merge_options(baml_options).parse_response(function_name="GenerateFollowup", llm_response=llm_response, mode="request")
        return typing.cast(types.FollowupMessage, result)

    def GenerateForwardingIntro(
        self, llm_response: str, baml_options: BamlCallOptions = {},
    ) -> types.ForwardingIntro:
        result = self.__options.merge_options(baml_options).parse_response(function_name="GenerateForwardingIntro", llm_response=llm_response, mode="request")
        return typing.cast(types.ForwardingIntro, result)

    def GenerateIntroRequest(
        self, llm_response: str, baml_options: BamlCallOptions = {},
    ) -> types.IntroductionMessage:
        result = self.__options.merge_options(baml_options).parse_response(function_name="GenerateIntroRequest", llm_response=llm_response, mode="request")
        return typing.cast(types.IntroductionMessage, result)

    def PlanIntroductionOrchestration(
        self, llm_response: str, baml_options: BamlCallOptions = {},
    ) -> types.IntroOrchestrationPlan:
        result = self.__options.merge_options(baml_options).parse_response(function_name="PlanIntroductionOrchestration", llm_response=llm_response, mode="request")
        return typing.cast(types.IntroOrchestrationPlan, result)

    

class LlmStreamParser:
    __options: DoNotUseDirectlyCallManager

    def __init__(self, options: DoNotUseDirectlyCallManager):
        self.__options = options

    def AssessIntroductionFeasibility(
        self, llm_response: str, baml_options: BamlCallOptions = {},
    ) -> stream_types.IntroFeasibility:
        result = self.__options.merge_options(baml_options).parse_response(function_name="AssessIntroductionFeasibility", llm_response=llm_response, mode="stream")
        return typing.cast(stream_types.IntroFeasibility, result)

    def AssessRelationshipQuality(
        self, llm_response: str, baml_options: BamlCallOptions = {},
    ) -> stream_types.RelationshipQualityAssessment:
        result = self.__options.merge_options(baml_options).parse_response(function_name="AssessRelationshipQuality", llm_response=llm_response, mode="stream")
        return typing.cast(stream_types.RelationshipQualityAssessment, result)

    def ExplainConvictionScore(
        self, llm_response: str, baml_options: BamlCallOptions = {},
    ) -> stream_types.ConvictionExplanation:
        result = self.__options.merge_options(baml_options).parse_response(function_name="ExplainConvictionScore", llm_response=llm_response, mode="stream")
        return typing.cast(stream_types.ConvictionExplanation, result)

    def ExplainPathChoice(
        self, llm_response: str, baml_options: BamlCallOptions = {},
    ) -> stream_types.PathExplanation:
        result = self.__options.merge_options(baml_options).parse_response(function_name="ExplainPathChoice", llm_response=llm_response, mode="stream")
        return typing.cast(stream_types.PathExplanation, result)

    def ExplainTrustScore(
        self, llm_response: str, baml_options: BamlCallOptions = {},
    ) -> stream_types.TrustExplanation:
        result = self.__options.merge_options(baml_options).parse_response(function_name="ExplainTrustScore", llm_response=llm_response, mode="stream")
        return typing.cast(stream_types.TrustExplanation, result)

    def ExtractRelationshipsFromText(
        self, llm_response: str, baml_options: BamlCallOptions = {},
    ) -> stream_types.RelationshipExtractionResult:
        result = self.__options.merge_options(baml_options).parse_response(function_name="ExtractRelationshipsFromText", llm_response=llm_response, mode="stream")
        return typing.cast(stream_types.RelationshipExtractionResult, result)

    def GenerateFollowup(
        self, llm_response: str, baml_options: BamlCallOptions = {},
    ) -> stream_types.FollowupMessage:
        result = self.__options.merge_options(baml_options).parse_response(function_name="GenerateFollowup", llm_response=llm_response, mode="stream")
        return typing.cast(stream_types.FollowupMessage, result)

    def GenerateForwardingIntro(
        self, llm_response: str, baml_options: BamlCallOptions = {},
    ) -> stream_types.ForwardingIntro:
        result = self.__options.merge_options(baml_options).parse_response(function_name="GenerateForwardingIntro", llm_response=llm_response, mode="stream")
        return typing.cast(stream_types.ForwardingIntro, result)

    def GenerateIntroRequest(
        self, llm_response: str, baml_options: BamlCallOptions = {},
    ) -> stream_types.IntroductionMessage:
        result = self.__options.merge_options(baml_options).parse_response(function_name="GenerateIntroRequest", llm_response=llm_response, mode="stream")
        return typing.cast(stream_types.IntroductionMessage, result)

    def PlanIntroductionOrchestration(
        self, llm_response: str, baml_options: BamlCallOptions = {},
    ) -> stream_types.IntroOrchestrationPlan:
        result = self.__options.merge_options(baml_options).parse_response(function_name="PlanIntroductionOrchestration", llm_response=llm_response, mode="stream")
        return typing.cast(stream_types.IntroOrchestrationPlan, result)

    